"""
Pydantic Models for Request/Response Validation
Ensures type safety and input validation across all API endpoints
"""

from pydantic import BaseModel, EmailStr, Field, validator
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum


# ==================== ENUMS ====================

class SkillMode(str, Enum):
    TEACH = "TEACH"
    LEARN = "LEARN"


class MatchStatus(str, Enum):
    PENDING = "PENDING"
    ACCEPTED = "ACCEPTED"
    REJECTED = "REJECTED"
    COMPLETED = "COMPLETED"


class SessionStatus(str, Enum):
    SCHEDULED = "SCHEDULED"
    COMPLETED = "COMPLETED"
    CANCELLED = "CANCELLED"


# ==================== USER MODELS ====================

class UserCreate(BaseModel):
    email: EmailStr
    name: str = Field(..., min_length=2, max_length=255)
    bio: Optional[str] = Field(None, max_length=1000)
    preferred_language: str = Field(default="English", max_length=50)
    
    @validator('name')
    def name_must_not_be_empty(cls, v):
        if not v or not v.strip():
            raise ValueError('Name cannot be empty')
        return v.strip()


class UserUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=2, max_length=255)
    bio: Optional[str] = Field(None, max_length=1000)
    preferred_language: Optional[str] = Field(None, max_length=50)
    avatar_url: Optional[str] = None


class UserResponse(BaseModel):
    id: str
    email: str
    name: str
    bio: Optional[str]
    preferred_language: str
    avatar_url: Optional[str]
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True


# ==================== SKILL MODELS ====================

class TimeSlot(BaseModel):
    day: str = Field(..., description="Day of week (Monday-Sunday)")
    time: str = Field(..., description="Time of day (morning/afternoon/evening)")
    
    @validator('day')
    def validate_day(cls, v):
        valid_days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
        if v not in valid_days:
            raise ValueError(f'Day must be one of {valid_days}')
        return v
    
    @validator('time')
    def validate_time(cls, v):
        valid_times = ['morning', 'afternoon', 'evening']
        if v not in valid_times:
            raise ValueError(f'Time must be one of {valid_times}')
        return v


class SkillCreate(BaseModel):
    name: str = Field(..., min_length=2, max_length=255)
    mode: SkillMode
    level: int = Field(..., ge=1, le=5, description="Skill level from 1 (beginner) to 5 (expert)")
    availability: List[TimeSlot] = Field(default_factory=list)
    
    @validator('name')
    def name_must_not_be_empty(cls, v):
        if not v or not v.strip():
            raise ValueError('Skill name cannot be empty')
        return v.strip()


class SkillUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=2, max_length=255)
    level: Optional[int] = Field(None, ge=1, le=5)
    availability: Optional[List[TimeSlot]] = None


class SkillResponse(BaseModel):
    id: str
    user_id: str
    name: str
    mode: SkillMode
    level: int
    availability: List[Dict[str, Any]]
    canonical_text: Optional[str]
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True


# ==================== MATCH MODELS ====================

class MatchScores(BaseModel):
    semantic_score: float = Field(..., ge=0, le=1)
    reciprocity_score: float = Field(..., ge=0, le=1)
    availability_score: float = Field(..., ge=0, le=1)
    preference_score: float = Field(..., ge=0, le=1)
    total_score: float = Field(..., ge=0, le=1)


class MatchCreate(BaseModel):
    user2_id: str
    skill1_id: str  # What user1 teaches
    skill2_id: str  # What user2 teaches
    
    # Scores will be calculated by backend
    # Explanation will be generated by AI


class MatchUpdate(BaseModel):
    status: MatchStatus


class MatchResponse(BaseModel):
    id: str
    user1_id: str
    user2_id: str
    skill1_id: str
    skill2_id: str
    semantic_score: float
    reciprocity_score: float
    availability_score: float
    preference_score: float
    total_score: float
    explanation: str
    status: MatchStatus
    created_at: datetime
    updated_at: datetime
    
    # Populated from joins
    user1: Optional[UserResponse] = None
    user2: Optional[UserResponse] = None
    skill1: Optional[SkillResponse] = None
    skill2: Optional[SkillResponse] = None
    
    class Config:
        from_attributes = True


# ==================== SESSION MODELS ====================

class SessionCreate(BaseModel):
    match_id: str
    agenda: str = Field(..., min_length=20, max_length=2000)
    scheduled_at: datetime
    duration_minutes: int = Field(..., description="Duration in minutes (30, 45, or 60)")
    meeting_link: Optional[str] = None
    
    @validator('duration_minutes')
    def validate_duration(cls, v):
        if v not in [30, 45, 60]:
            raise ValueError('Duration must be 30, 45, or 60 minutes')
        return v
    
    @validator('scheduled_at')
    def validate_future_date(cls, v):
        if v <= datetime.now():
            raise ValueError('Session must be scheduled in the future')
        return v


class SessionUpdate(BaseModel):
    agenda: Optional[str] = Field(None, min_length=20, max_length=2000)
    scheduled_at: Optional[datetime] = None
    status: Optional[SessionStatus] = None
    meeting_link: Optional[str] = None
    notes: Optional[str] = Field(None, max_length=2000)


class SessionResponse(BaseModel):
    id: str
    match_id: str
    agenda: str
    scheduled_at: datetime
    duration_minutes: int
    status: SessionStatus
    meeting_link: Optional[str]
    notes: Optional[str]
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True


# ==================== MESSAGE MODELS ====================

class MessageCreate(BaseModel):
    match_id: str
    content: str = Field(..., min_length=1, max_length=2000)
    
    @validator('content')
    def content_must_not_be_empty(cls, v):
        if not v or not v.strip():
            raise ValueError('Message content cannot be empty')
        return v.strip()


class MessageResponse(BaseModel):
    id: str
    match_id: str
    sender_id: str
    content: str
    is_read: bool
    created_at: datetime
    
    # Populated from join
    sender: Optional[Dict[str, Any]] = None
    
    class Config:
        from_attributes = True


# ==================== AI ASSISTANT MODELS ====================

class ChatMessage(BaseModel):
    role: str = Field(..., description="Role: 'user' or 'assistant'")
    content: str = Field(..., min_length=1, max_length=2000)
    
    @validator('role')
    def validate_role(cls, v):
        if v not in ['user', 'assistant']:
            raise ValueError('Role must be "user" or "assistant"')
        return v


class ChatRequest(BaseModel):
    messages: List[ChatMessage] = Field(..., min_items=1)
    context: Optional[Dict[str, Any]] = None


class ChatResponse(BaseModel):
    response: str
    timestamp: datetime = Field(default_factory=datetime.now)


class AgendaGenerateRequest(BaseModel):
    match_id: str
    duration_minutes: int = Field(..., description="Duration in minutes (30, 45, or 60)")
    
    @validator('duration_minutes')
    def validate_duration(cls, v):
        if v not in [30, 45, 60]:
            raise ValueError('Duration must be 30, 45, or 60 minutes')
        return v


class AgendaGenerateResponse(BaseModel):
    agenda: str
    match_id: str


# ==================== GENERAL RESPONSE MODELS ====================

class ErrorResponse(BaseModel):
    error: str
    detail: Optional[str] = None
    timestamp: datetime = Field(default_factory=datetime.now)


class SuccessResponse(BaseModel):
    message: str
    data: Optional[Dict[str, Any]] = None
    timestamp: datetime = Field(default_factory=datetime.now)
